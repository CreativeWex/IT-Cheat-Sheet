### Содержание <br>
[1. Абстрактный класс](#T1) <br>
[2. Основные понятия интерфейса](#T2) <br>
[3. Реализация интерфейсов в базовых и производных классах.](#T3) <br>
[4. Множественная реализация интерфейсов](#T4) <br>

<a name="T1"></a>

# Абстрактный класс

Класс, экземпляр которого(объект) **нельзя создать**, используются для описания общего функционала, который могут наследовать и использовать производные классы.

```C#
abstract class Transport
{
    public abstract void Move();
}
```

Абстрактный класс может определять конструкторы, которые будут вызываться в конструкторах производных классов.

<br>

## Абстрактные члены классов

Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова `abstract` и не имеют никакого функционала. В частности, абстрактными могут быть:
- методы + свойства
- индексаторы
- события

>При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. 

Если класс имеет хотя бы один абстрактный элемент, то этот класс должен быть определен как абстрактный.

>Абстрактные члены также, как и виртуальные, являются частью полиморфного интерфейса. Но если в случае с виртуальными методами мкласс-наследник наследует реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный этими абстрактными методами.

<br><a name="T2"></a>

# Интерфейсы

Ссылочный тип, **который может определять набор методов и свойств**.  Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.

Методы интерфейса объявляются без модификатора доступа (по умолчанию public)  **ДО ВЕРСИИ С# 8.0**

**Не реализовывали методы и свойства до версии С# 8.0.**
```C#
interface Iназвание // название начинается с 'I'
{
    //Методы
    //Индексаторы
    //События
    //Статические поля и константы, в отличие от абстрактных классов
}
```
Как и классы, интерфейсы по умолчанию имеют уровень доступа `internal`.

Пример:
```C#
interface IMovable // название начинается с 'I'
{
    void Move();
}

class Person : IMovable
{
    public void Move()
    {
        Console.WriteLine("Человек идет");
    }
}

class Car: IMovable
{
    public void Move()
    {
        Console.WriteLine("Автомобиль едет");
    }
}
```
## Модификаторы доступа
Константы и статические переменные, объявленные в интерфейсе будут иметь модификатор `public`. Пример обращения к константам интерфейса `IMovable`:
```C#
Console.WriteLine(IMovable.maxSpeed);   // 60
Console.WriteLine(IMovable.minSpeed);   // 0
```
<a name="T3"></a>

## Реализация интерфейсов в базовых и производных классах
Если класс применяет интерфейс, то этот класс должен реализовать все методы и свойства интерфейса, которые не имеют реализации по умолчанию. **Однако также можно и не реализовать методы, сделав их абстрактными, переложив право их реализации на производные классы:**

```C#
interface IMovable
{
    void Move(); // инициализировали метод
}
abstract class Person : IMovable
{
    public abstract void Move(); //реализовали метод
}
class Driver : Person
{
    public override void Move() => Console.WriteLine("Шофер ведет машину"); //переопределили метод
}
```
**Изменение реализации интерфейсов** в произодных классах можно реализовать при помощи виртуальных/абстрактных методов

```C#
interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    public virtual void Move() => Console.WriteLine("Move in BaseAction");
}
class HeroAction : BaseAction
{
    public override void Move() => Console.WriteLine("Move in HeroAction");
}
```

<a name="T4"></a>

## Множественная реализация интерфейсов
Интерфейсы позволяют частично обойти ограничение множественного наследования, поскольку в C# классы и структуры могут реализовать сразу несколько интерфейсов. Все реализуемые интерфейсы указываются через запятую:

```C#
class myClass: myInterface1, myInterface2, myInterface3, ...
{
     // тело
}
```
Пример
```C#
interface IAccount
{
    int CurrentSum {get; }
    void Put(int sum);
    void Withdraw(int sum);
}

interface IClient
{
    string Name {get; set; }
    void Put(int sum);
    void Withdraw(int sum);
}

class Client : IAccount, IClient
{
    int sum;
    public int CurrentSum{ get {return sum; }}
    public string Name {get; set; }
    public void Put(int sum)
    {
        this.su, += sum;
    }
    public void WithDraw(int sum)
    {
        if (this.sum >= sum)
            this.sum -= sum;
    }
}
```